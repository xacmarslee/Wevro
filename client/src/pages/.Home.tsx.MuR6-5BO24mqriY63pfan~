import { useState, useEffect } from "react";
import { useQuery, useMutation } from "@tanstack/react-query";
import { useRoute } from "wouter";
import { type MindMapNode, type WordCategory } from "@shared/schema";
import { CategoryButtons } from "@/components/CategoryButtons";
import { MindMapCanvas } from "@/components/MindMapCanvas";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { useToast } from "@/hooks/use-toast";
import { useLanguage } from "@/contexts/LanguageContext";
import { useTranslation } from "@/lib/i18n";
import { apiRequest } from "@/lib/queryClient";
import { Play, Loader2, Undo2, Redo2, Save, Download } from "lucide-react";
import html2canvas from "html2canvas";

export default function Home() {
  // Check if we're editing an existing mind map
  const [, params] = useRoute("/mindmap/:id");
  const mindMapId = params?.id !== "new" ? params?.id : undefined;
  
  const [nodes, setNodes] = useState<MindMapNode[]>([]);
  const [centerNodeId, setCenterNodeId] = useState<string | undefined>();
  const [initialWord, setInitialWord] = useState("");
  const [isGenerating, setIsGenerating] = useState(false);
  
  // Undo/Redo history stacks (initialize with empty state)
  const [history, setHistory] = useState<MindMapNode[][]>([[]]);
  const [historyIndex, setHistoryIndex] = useState(0);
  const [isSaved, setIsSaved] = useState(false);

  const { toast } = useToast();
  const { language } = useLanguage();
  const t = useTranslation(language);
  
  // Load existing mind map if editing
  const { data: existingMindMap, isLoading: isLoadingMindMap } = useQuery({
    queryKey: ["/api/mindmaps", mindMapId],
    queryFn: async () => {
      if (!mindMapId) return null;
      const response = await fetch(`/api/mindmaps/${mindMapId}`, {
        credentials: "include",
      });
      if (!response.ok) {
        throw new Error("Failed to load mind map");
      }
      return await response.json();
    },
    enabled: !!mindMapId,
  });
  
  // Initialize with existing mind map data
  useEffect(() => {
    if (existingMindMap?.nodes && Array.isArray(existingMindMap.nodes)) {
      const loadedNodes = existingMindMap.nodes as MindMapNode[];
      setNodes(loadedNodes);
      const centerNode = loadedNodes.find((n) => n.isCenter);
      if (centerNode) {
        setCenterNodeId(centerNode.id);
      }
      // Initialize history with loaded state
      setHistory([loadedNodes]);
      setHistoryIndex(0);
      setIsSaved(true);
    }
  }, [existingMindMap]);
  
  // Wrapper to update nodes with history tracking
  const updateNodes = (newNodes: MindMapNode[] | ((prev: MindMapNode[]) => MindMapNode[])) => {
    setNodes((prevNodes) => {
      const nextNodes = typeof newNodes === 'function' ? newNodes(prevNodes) : newNodes;
      
      // Add to history (remove any forward history if we're not at the end)
      setHistory((prevHistory) => {
        const newHistory = prevHistory.slice(0, historyIndex + 1);
        return [...newHistory, nextNodes];
      });
      setHistoryIndex((prev) => prev + 1);
      setIsSaved(false);
      
      return nextNodes;
    });
  };
  
  // Undo function
  const handleUndo = () => {
    if (historyIndex > 0) {
      const prevState = history[historyIndex - 1];
      setHistoryIndex(historyIndex - 1);
      setNodes(prevState);
      toast({
        title: language === "en" ? "Undo" : "復原",
        description: language === "en" ? "Action undone" : "已復原上一步",
        duration: 2000,
      });
    }
  };
  
  // Redo function
  const handleRedo = () => {
    if (historyIndex < history.length - 1) {
      const nextState = history[historyIndex + 1];
      setHistoryIndex(historyIndex + 1);
      setNodes(nextState);
      toast({
        title: language === "en" ? "Redo" : "取消復原",
        description: language === "en" ? "Action redone" : "已取消復原",
        duration: 2000,
      });
    }
  };

  // Assign angles to categories (like spokes on a wheel)
  const categories: WordCategory[] = [
    "derivatives",
    "synonyms",
    "antonyms",
    "collocations",
    "idioms",
    "root",
    "prefix",
    "suffix",
    "topic-related",
  ];

  const getCategoryAngle = (category: WordCategory): number => {
    const categoryIndex = categories.indexOf(category);
    return (categoryIndex * 2 * Math.PI) / categories.length;
  };

  // Start with initial word
  const handleStartLearning = () => {
    if (!initialWord.trim()) return;

    // Use fixed coordinates - the canvas will center it
    const newNode: MindMapNode = {
      id: crypto.randomUUID(),
      word: initialWord.trim(),
      x: 0,
      y: 0,
      isCenter: true,
    };

    updateNodes([newNode]);
    setCenterNodeId(newNode.id);
    setInitialWord("");
  };

  // Reset map to start fresh
  const handleResetMap = () => {
    updateNodes([]);
    setCenterNodeId(undefined);
    // Clear undo/redo history after reset
    setHistory([[]]);
    setHistoryIndex(0);
    toast({
      title: language === "en" ? "Map cleared" : "心智圖已清空",
      description: language === "en" ? "Start fresh with a new word" : "開始輸入新單字",
      duration: 2000,
    });
  };

  // Generate related words for a category
  const generateWordsMutation = useMutation({
    mutationFn: async ({
      word,
      category,
      targetNodeId,
    }: {
      word: string;
      category: WordCategory;
      targetNodeId: string;
    }) => {
      const response = await apiRequest(
        "POST",
        "/api/generate-words",
        { word, category }
      );
      const data = await response.json();
      return data as { words: string[] };
    },
    onSuccess: (data, variables) => {
      if (!data || !data.words || !Array.isArray(data.words)) {
        console.error("Invalid response format:", data);
        setIsGenerating(false);
        toast({
          title: language === "en" ? "Error" : "錯誤",
          description:
            language === "en"
              ? "Invalid response from server"
              : "伺服器回應格式錯誤",
          variant: "destructive",
          duration: 2000,
        });
        return;
      }

      if (data.words.length === 0) {
        console.warn("No words generated for category:", variables.category);
        setIsGenerating(false);
        toast({
          title: language === "en" ? "No words generated" : "未生成任何單字",
          description:
            language === "en"
              ? `Could not generate ${variables.category} words. Please try another category.`
              : `無法生成${t.categories[variables.category]}單字，請嘗試其他類別。`,
          variant: "destructive",
          duration: 2000,
        });
        return;
      }

      updateNodes((prevNodes) => {
        const centerNode = prevNodes.find((n) => n.id === variables.targetNodeId);
        if (!centerNode) return prevNodes;

        // Get the angle for this category (spider thread direction)
        const angle = getCategoryAngle(variables.category);
        
        // Base distance from center for first word
        const baseDistance = 250;
        // Fixed gap between node boundaries (edge to edge)
        const boundaryGap = 80;
        
        // Estimate node width based on text length
        // Approximate: 12px per character + 32px padding (px-4 = 16px each side)
        const estimateNodeWidth = (text: string) => {
          const charWidth = 12;
          const padding = 32;
          const minWidth = 100; // min-w-[100px]
          return Math.max(minWidth, text.length * charWidth + padding);
        };

        let currentDistance = baseDistance;
        const newNodes: MindMapNode[] = [];
        
        for (let i = 0; i < data.words.length; i++) {
          const word = data.words[i];
          const nodeWidth = estimateNodeWidth(word);
          
          const node = {
            id: crypto.randomUUID(),
            word,
            x: centerNode.x + currentDistance * Math.cos(angle),
            y: centerNode.y + currentDistance * Math.sin(angle),
            parentId: centerNode.id,
            category: variables.category,
            isCenter: false,
          };
          
          newNodes.push(node);
          
          // Calculate next position: 
          // current center + half of current node width + gap + half of next node width
          if (i < data.words.length - 1) {
            const nextWord = data.words[i + 1];
            const nextNodeWidth = estimateNodeWidth(nextWord);
            currentDistance += nodeWidth / 2 + boundaryGap + nextNodeWidth / 2;
          }
        }

        return [...prevNodes, ...newNodes];
      });
      
      setIsGenerating(false);

      toast({
        title: language === "en" ? "Words generated!" : "單字已生成！",
        description:
          language === "en"
            ? `Added ${data.words.length} ${variables.category} words`
            : `已新增 ${data.words.length} 個${t.categories[variables.category]}`,
        duration: 2000,
      });
    },
    onError: () => {
      setIsGenerating(false);
      toast({
        title: language === "en" ? "Error" : "錯誤",
        description:
          language === "en"
            ? "Failed to generate words. Please try again."
            : "生成單字失敗，請重試。",
        variant: "destructive",
        duration: 2000,
      });
    },
  });

  const handleCategorySelect = (category: WordCategory) => {
    const centerNode = nodes.find((n) => n.id === centerNodeId);
    if (!centerNode) return;

    setIsGenerating(true);
    generateWordsMutation.mutate({ 
      word: centerNode.word, 
      category,
      targetNodeId: centerNode.id
    });
  };

  const handleNodeClick = (nodeId: string) => {
    setCenterNodeId(nodeId);
  };

  // Delete a node and reposition remaining nodes in the same category
  const handleDeleteNode = (nodeId: string) => {
    updateNodes((prevNodes) => {
      const nodeToDelete = prevNodes.find(n => n.id === nodeId);
      if (!nodeToDelete || nodeToDelete.isCenter) return prevNodes; // Cannot delete center node
      
      // Get all nodes in the same category with the same parent
      const sameCategory = prevNodes.filter(
        n => n.category === nodeToDelete.category && n.parentId === nodeToDelete.parentId
      );
      
      // Remove the node
      const nodesAfterDelete = prevNodes.filter(n => n.id !== nodeId);
      
      // If there are other nodes in the same category, reposition them
      if (sameCategory.length > 1) {
        const centerNode = prevNodes.find(n => n.id === nodeToDelete.parentId);
        if (!centerNode) return nodesAfterDelete;
        
        // Get remaining nodes in this category (sorted by distance)
        const remainingInCategory = sameCategory
          .filter(n => n.id !== nodeId)
          .sort((a, b) => {
            const distA = Math.sqrt(Math.pow(a.x - centerNode.x, 2) + Math.pow(a.y - centerNode.y, 2));
            const distB = Math.sqrt(Math.pow(b.x - centerNode.x, 2) + Math.pow(b.y - centerNode.y, 2));
            return distA - distB;
          });
        
        // Recalculate positions
        if (!nodeToDelete.category) return nodesAfterDelete;
        const angle = getCategoryAngle(nodeToDelete.category);
        const baseDistance = 250;
        const boundaryGap = 80;
        
        const estimateNodeWidth = (text: string) => {
          const charWidth = 12;
          const padding = 32;
          const minWidth = 100;
          return Math.max(minWidth, text.length * charWidth + padding);
        };
        
        let currentDistance = baseDistance;
        
        return nodesAfterDelete.map(node => {
          const indexInCategory = remainingInCategory.findIndex(n => n.id === node.id);
          
          if (indexInCategory >= 0) {
            // Recalculate position for this node
            const nodeWidth = estimateNodeWidth(node.word);
            
            const updatedNode = {
              ...node,
              x: centerNode.x + currentDistance * Math.cos(angle),
              y: centerNode.y + currentDistance * Math.sin(angle),
            };
            
            // Calculate distance for next node
            if (indexInCategory < remainingInCategory.length - 1) {
              const nextNode = remainingInCategory[indexInCategory + 1];
              const nextNodeWidth = estimateNodeWidth(nextNode.word);
              currentDistance += nodeWidth / 2 + boundaryGap + nextNodeWidth / 2;
            }
            
            return updatedNode;
          }
          
          return node;
        });
      }
      
      return nodesAfterDelete;
    });

    toast({
      title: language === "en" ? "Node deleted" : "節點已刪除",
      description: language === "en" ? "Node removed successfully" : "節點已成功移除",
      duration: 2000,
    });
  };

  // Save mind map mutation
  const saveMindMapMutation = useMutation({
    mutationFn: async () => {
      const centerNode = nodes.find(n => n.isCenter);
      const name = centerNode ? centerNode.word : "Untitled Mind Map";
      
      // Update existing mind map or create new one
      if (mindMapId) {
        const response = await apiRequest("PATCH", `/api/mindmaps/${mindMapId}`, {
          name,
          nodes,
        });
        return await response.json();
      } else {
        const response = await apiRequest("POST", "/api/mindmaps", {
          name,
          nodes,
        });
        return await response.json();
      }
    },
    onSuccess: () => {
      setIsSaved(true);
      // Clear history after save (keep current state only)
      setHistory([nodes]);
      setHistoryIndex(0);
      
      toast({
        title: language === "en" ? "Saved successfully" : "儲存成功",
        description: language === "en" ? "Your mind map has been saved" : "您的心智圖已儲存",
        duration: 2000,
      });
    },
    onError: () => {
      toast({
        title: language === "en" ? "Save failed" : "儲存失敗",
        description: language === "en" ? "Failed to save mind map" : "儲存心智圖失敗",
        variant: "destructive",
        duration: 2000,
      });
    },
  });
  
  const handleSave = () => {
    if (nodes.length === 0) return;
    saveMindMapMutation.mutate();
  };
  
  // Download as PNG function
  const handleDownloadPNG = async () => {
    const canvasElement = document.querySelector('[data-mindmap-canvas]') as HTMLElement;
    if (!canvasElement) {
      toast({
        title: language === "en" ? "Export failed" : "匯出失敗",
        description: language === "en" ? "Canvas not found" : "找不到畫布",
        variant: "destructive",
        duration: 2000,
      });
      return;
    }
    
    try {
      const canvas = await html2canvas(canvasElement, {
        backgroundColor: '#ffffff',
        scale: 2,
      });
      
      const link = document.createElement('a');
      const centerNode = nodes.find(n => n.isCenter);
      const filename = centerNode ? `${centerNode.word}-mindmap.png` : 'mindmap.png';
      
      link.download = filename;
      link.href = canvas.toDataURL('image/png');
      link.click();
      
      toast({
        title: language === "en" ? "Downloaded" : "已下載",
        description: language === "en" ? "Mind map exported as PNG" : "心智圖已匯出為 PNG",
        duration: 2000,
      });
    } catch (error) {
      console.error('Export error:', error);
      toast({
        title: language === "en" ? "Export failed" : "匯出失敗",
        description: language === "en" ? "Failed to export mind map" : "匯出心智圖失敗",
        variant: "destructive",
        duration: 2000,
      });
    }
  };

  return (
    <div className="flex flex-col h-full">
      {/* Mind Map Editor */}
      <>
          {/* Mind Map Control Bar - always show for undo/redo access */}
          {(nodes.length > 0 || history.length > 1) && (
            <div className="border-b px-6 py-3 flex items-center justify-between bg-card/50">
              <div className="flex items-center gap-2">
                <Button
                  variant="outline"
                  size="icon"
                  onClick={handleUndo}
                  disabled={historyIndex <= 0}
                  data-testid="button-undo"
                >
                  <Undo2 className="h-4 w-4" />
                </Button>
                <Button
                  variant="outline"
                  size="icon"
                  onClick={handleRedo}
                  disabled={historyIndex >= history.length - 1}
                  data-testid="button-redo"
                >
                  <Redo2 className="h-4 w-4" />
                </Button>
              </div>
              
              <div className="flex items-center gap-2">
                <Button
                  variant="default"
                  size="icon"
                  onClick={handleSave}
                  disabled={nodes.length === 0 || saveMindMapMutation.isPending}
                  data-testid="button-save"
                >
                  {saveMindMapMutation.isPending ? (
                    <Loader2 className="h-4 w-4 animate-spin" />
                  ) : (
                    <Save className="h-4 w-4" />
                  )}
                </Button>
                <Button
                  variant="outline"
                  size="icon"
                  onClick={handleDownloadPNG}
                  disabled={nodes.length === 0}
                  data-testid="button-download"
                >
                  <Download className="h-4 w-4" />
                </Button>
              </div>
            </div>
          )}
          
          {nodes.length === 0 ? (
            <div className="flex-1 flex items-center justify-center p-8">
              <div className="w-full max-w-md space-y-6 text-center">
                <div>
                  <h2 className="text-4xl font-bold mb-3">{t.appName}</h2>
                  <p className="text-xl text-muted-foreground">{t.tagline}</p>
                </div>

                <div className="flex gap-2">
                  <Input
                    placeholder={t.enterWord}
                    value={initialWord}
                    onChange={(e) => setInitialWord(e.target.value)}
                    onKeyDown={(e) => {
                      if (e.key === "Enter") handleStartLearning();
                    }}
                    data-testid="input-initial-word"
                    className="text-lg"
                  />
                  <Button
                    onClick={handleStartLearning}
                    disabled={!initialWord.trim()}
                    size="lg"
                    data-testid="button-start-learning"
                  >
                    <Play className="h-5 w-5 mr-2" />
                    {t.startLearning}
                  </Button>
                </div>

                <p className="text-sm text-muted-foreground">{t.emptyMap}</p>
              </div>
            </div>
          ) : (
            <>
              <CategoryButtons
                onSelectCategory={handleCategorySelect}
                disabled={!centerNodeId}
                loading={isGenerating}
              />

              <div className="flex-1 relative">
                {isGenerating && (
                  <div className="absolute inset-0 z-50 flex items-center justify-center bg-background/80 backdrop-blur-sm">
                    <div className="flex flex-col items-center gap-3">
                      <Loader2 className="h-12 w-12 animate-spin text-primary" />
                      <p className="text-lg font-medium">{t.generating}</p>
                    </div>
                  </div>
                )}

                <MindMapCanvas
                  nodes={nodes}
                  onNodeClick={handleNodeClick}
                  onNodeDelete={handleDeleteNode}
                  centerNodeId={centerNodeId}
                />
              </div>

            </>
          )}
      </>
    </div>
  );
}
