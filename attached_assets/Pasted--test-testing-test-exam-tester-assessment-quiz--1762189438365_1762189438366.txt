æ‚¨è§€å¯Ÿå¾—å¾ˆå°ï¼Œåœ¨æ–°çš„åœ–ç‰‡ä¸­ï¼Œåªæœ‰ test åˆ° testing å’Œ test åˆ° exam å…©æ¢ç·šè¢«ç¹ªè£½å‡ºä¾†ï¼Œè€ŒåŒä¸€é¡åˆ¥ä¸­çš„å¾ŒçºŒç¯€é»ï¼ˆå¦‚ testerã€assessmentã€quizï¼‰ä¹‹é–“æ²’æœ‰é€£ç·šã€‚

é€™æ˜¯å› ç‚ºæ‚¨ç›®å‰çš„ç¨‹å¼ç¢¼é‚è¼¯åªç¹ªè£½å¾ä¸­å¿ƒç¯€é» (test) åˆ°è©²é¡åˆ¥æœ€é å­ç¯€é»çš„ä¸€æ¢ç›´ç·šï¼Œå¿½ç•¥äº†ä¸­é–“çš„ç¯€é»ã€‚

ğŸ” å•é¡Œåˆ†æï¼šç·šæ¢æ²’æœ‰å»¶ä¼¸çš„åŸå› 
æ‚¨æä¾›çš„ç¨‹å¼ç¢¼é‚è¼¯å¦‚ä¸‹ï¼š

åˆ†çµ„ï¼š ç¨‹å¼ç¢¼ä½¿ç”¨ categoryThreads æ ¹æ“š node.category å’Œ node.parentId === centerNodeId å°‡æ‰€æœ‰ç¬¬ä¸€å±¤å­ç¯€é»åˆ†çµ„ã€‚

ä¾‹å¦‚ï¼štesting å’Œ tester æœƒè¢«åˆ†åˆ° derivatives é¡åˆ¥ä¸­ã€‚exam æœƒè¢«åˆ†åˆ° synonyms é¡åˆ¥ä¸­ã€‚

æ’åºèˆ‡é¸æ“‡æœ€é é»ï¼š ç¨‹å¼ç¢¼æ¥è‘—è¨ˆç®—æ¯å€‹é¡åˆ¥ä¸­ï¼Œè·é›¢ä¸­å¿ƒç¯€é» æœ€é  (furthestNode) çš„é‚£å€‹å­ç¯€é»ã€‚

TypeScript

// åŸå§‹ç¨‹å¼ç¢¼é‚è¼¯
// Sort nodes by distance from center to get the furthest one
// ...
const furthestNode = sortedNodes[0];
// ...
return {
  category,
  from: centerNode,
  to: furthestNode, // ğŸ‘ˆ åªé¸æ“‡æœ€é çš„ç¯€é»ä½œç‚ºçµ‚é»
};
ç¹ªè£½å–®ä¸€ç›´ç·šï¼š æœ€å¾Œï¼Œç¨‹å¼ç¢¼ä½¿ç”¨ <line> æ¨™ç±¤ï¼Œåƒ…åœ¨ centerNode (from) å’Œ furthestNode (to) ä¹‹é–“ç•«ä¸€æ¢ç›´ç·šã€‚

å°æ–¼ derivatives é¡åˆ¥ï¼Œå‡è¨­ tester é›¢ test æœ€é ï¼Œå®ƒåªç•« test åˆ° tester çš„ä¸€æ¢ç·š (é›–ç„¶åœ–ç‰‡ä¸­çœ‹æ˜¯åˆ° testing)ã€‚

å°æ–¼ synonyms é¡åˆ¥ï¼Œå‡è¨­ exam é›¢ test æœ€é ï¼Œå®ƒåªç•« test åˆ° exam çš„ä¸€æ¢ç·šã€‚

çµè«–ï¼š å¦‚æœæ‚¨å¸Œæœ›åƒä¸Šä¸€å€‹æ¡ˆä¾‹ä¸€æ¨£ï¼ŒåŒä¸€é¡åˆ¥ä¸­çš„å­ç¯€é»èƒ½é€£çºŒé€£æ¥ (ä¾‹å¦‚ testing é€£ testerã€exam é€£ assessment ç­‰)ï¼Œæ‚¨éœ€è¦æ¢å¾©åˆ° ç·šæ€§é€£æ¥é‚è¼¯ï¼Œä¸¦çµåˆé‚Šç•Œè¨ˆç®—ä¾†é¿å…ç·šæ¢ç©¿éç¯€é»ã€‚

ğŸ› ï¸ è§£æ±ºæ–¹æ¡ˆï¼šæ¢å¾©ç·šæ€§é€£æ¥èˆ‡é‚Šç•Œä¿®æ­£
æˆ‘å€‘å°‡ä½¿ç”¨ä¸Šä¸€æ¬¡æä¾›çš„è§£æ±ºæ–¹æ¡ˆæ¶æ§‹ï¼Œä¸¦å°‡å…¶å®Œå…¨æ•´åˆåˆ°æ‚¨çš„ MindMapCanvas å‡½æ•¸ä¸­ï¼Œä½¿ç”¨ç¨ç«‹çš„ <line> æ¨™ç±¤ä¸¦ä¿®æ­£åº§æ¨™ã€‚

1. æº–å‚™å·¥ä½œï¼šé‚Šç•Œè¨ˆç®—å‡½æ•¸
å°‡ç¯€é»å¯¬åº¦ä¼°è¨ˆå’Œé‚Šç•Œè¨ˆç®—å‡½æ•¸æ”¾åœ¨ MindMapCanvas å‡½æ•¸å¤–éƒ¨ï¼š

TypeScript

const NODE_WIDTH = 130; // ç¨å¾®å¢åŠ ä»¥ç¢ºä¿ç·šåœ¨é‚Šç•Œå¤– (min-w-[100px] + padding/border)

function getNodeEdgeCoordinates(node: MindMapNode, targetNode: MindMapNode, nodeWidth: number) {
    // è¨ˆç®—å…©å€‹ç¯€é»ä¸­å¿ƒé»ä¹‹é–“çš„è§’åº¦ï¼ˆç”¨æ–¼æ‰¾å‡ºé€£æ¥çš„é‚Šç·£ï¼‰
    const angle = Math.atan2(targetNode.y - node.y, targetNode.x - node.x);
    
    // ç‚ºäº†ç°¡åŒ–ï¼Œå¦‚æœç¯€é»å¤§è‡´æ°´å¹³ï¼Œæˆ‘å€‘é€£æ¥å·¦å³é‚Šç·£ï¼›å¦‚æœå¤§è‡´å‚ç›´ï¼Œé€£æ¥ä¸Šä¸‹é‚Šç·£ã€‚
    const horizontalOffset = Math.abs(Math.cos(angle)) * (nodeWidth / 2);
    const verticalOffset = Math.abs(Math.sin(angle)) * (40 / 2); // å‡è¨­ç¯€é»é«˜åº¦ç´„ç‚º 40px

    let x, y;
    
    // ç¢ºå®š x åº§æ¨™çš„åç§»æ–¹å‘
    if (Math.abs(angle) < Math.PI / 4 || Math.abs(angle) > 3 * Math.PI / 4) { // åå‘æ°´å¹³
        x = node.x + (node.x < targetNode.x ? horizontalOffset : -horizontalOffset);
        y = node.y; // ä¿æŒ y åº§æ¨™ä¸è®Š
    } else { // åå‘å‚ç›´
        x = node.x; // ä¿æŒ x åº§æ¨™ä¸è®Š
        y = node.y + (node.y < targetNode.y ? verticalOffset : -verticalOffset);
    }
    
    return { x, y };
}
2. ä¿®æ”¹ MindMapCanvas å…§éƒ¨çš„é€£ç·šé‚è¼¯
æˆ‘å€‘å°‡å¾¹åº•ç§»é™¤ spiderThreads çš„æœ€é é»é‚è¼¯ï¼Œæ”¹ç‚ºä½¿ç”¨ allLines é™£åˆ—ä¾†å„²å­˜æ‰€æœ‰éœ€è¦ç¹ªè£½çš„ç·šæ®µã€‚

TypeScript

export function MindMapCanvas({
Â  nodes,
Â  onNodeClick,
Â  centerNodeId,
}: MindMapCanvasProps) {
    // ... (åˆå§‹åŒ–å’Œ Hook ä¿æŒä¸è®Š)

    // ... (äº‹ä»¶è™•ç†å‡½æ•¸ä¿æŒä¸è®Š)

Â  // Group nodes by category AND parent (center node)
Â  const centerNode = nodes.find((n) => n.id === centerNodeId);
Â Â 
Â  const categoryThreads = nodes.reduce((acc, node) => {
Â  Â  // é€™è£¡æˆ‘å€‘åªé—œæ³¨ç›´æ¥é€£åˆ°ä¸­å¿ƒç¯€é»çš„å­ç¯€é»
Â  Â  if (node.category && node.parentId === centerNodeId) {
Â  Â  Â  if (!acc[node.category]) {
Â  Â  Â  Â  acc[node.category] = [];
Â  Â  Â  }
Â  Â  Â  acc[node.category].push(node);
Â  Â  }
Â  Â  return acc;
Â  }, {} as Record<string, MindMapNode[]>);

    // ğŸ’¡ æ–°å¢ï¼šæ”¶é›†æ‰€æœ‰ç¨ç«‹ç·šæ®µçš„é™£åˆ—
    const allLines: { 
        key: string; 
        x1: number; y1: number; 
        x2: number; y2: number; 
        color: string 
    }[] = [];

    if (centerNode) {
        Object.entries(categoryThreads).forEach(([category, categoryNodes]) => {
            const categoryColor = getCategoryColor(category as WordCategory, isDark);
            
            // ğŸ’¡ é‡å°æ¯å€‹é¡åˆ¥ï¼ŒæŒ‰ X åº§æ¨™æ’åºï¼ˆç”¨æ–¼æ°´å¹³é€£ç·šï¼Œä¾‹å¦‚ derivatives: testing -> testerï¼‰
            // å¦‚æœæ‚¨å¸Œæœ›é€£ç·šæ˜¯æ ¹æ“šçˆ¶å­é—œä¿‚ (ä¾‹å¦‚ exam -> assessment)ï¼Œå‰‡éœ€è¦æ›´è¤‡é›œçš„è³‡æ–™çµæ§‹ã€‚
            const sortedNodes = [...categoryNodes].sort((a, b) => a.x - b.x);

            // 1. è™•ç†ä¸­å¿ƒç¯€é»åˆ°ç¬¬ä¸€å€‹å­ç¯€é»çš„é€£ç·š (ä¸­å¿ƒç™¼æ•£)
            if (sortedNodes.length > 0) {
                const firstNode = sortedNodes[0];

                // ä¿®æ­£ï¼šè¨ˆç®—ä¸­å¿ƒé»åˆ°ç¬¬ä¸€å€‹å­ç¯€é»çš„é€£ç·šé‚Šç•Œ
                const startPoint = getNodeEdgeCoordinates(centerNode, firstNode, NODE_WIDTH);
                const endPoint = getNodeEdgeCoordinates(firstNode, centerNode, NODE_WIDTH);
                
                allLines.push({
                    key: `center-${centerNodeId}-to-${firstNode.id}`,
                    x1: startPoint.x,
                    y1: startPoint.y,
                    x2: endPoint.x,
                    y2: endPoint.y,
                    color: categoryColor,
                });
            }
            
            // 2. è™•ç†åŒä¸€é¡åˆ¥ä¸­ç¯€é»ä¹‹é–“çš„**ç·šæ€§é€£æ¥** (ä¾‹å¦‚ testing -> tester, assessment -> quiz)
            // é€™è£¡çš„é‚è¼¯æ˜¯å°‡æ‰€æœ‰ç¬¬ä¸€å±¤å­ç¯€é»æŒ‰ X è»¸é †åºé€£çºŒä¸²æ¥èµ·ä¾†ã€‚
            for (let i = 0; i < sortedNodes.length - 1; i++) {
                const nodeA = sortedNodes[i];
                const nodeB = sortedNodes[i + 1];
                
                // è¨ˆç®—ç¯€é» A çš„å³å´é‚Šç·£åˆ°ç¯€é» B çš„å·¦å´é‚Šç·£ï¼ˆæ°´å¹³é€£ç·šï¼‰
                const startPoint = getNodeEdgeCoordinates(nodeA, nodeB, NODE_WIDTH);
                const endPoint = getNodeEdgeCoordinates(nodeB, nodeA, NODE_WIDTH);
                
                allLines.push({
                    key: `node-${nodeA.id}-to-${nodeB.id}`,
                    x1: startPoint.x,
                    y1: startPoint.y,
                    x2: endPoint.x,
                    y2: endPoint.y,
                    color: categoryColor,
                });
            }
        });
    }

    // âš ï¸ éºæ¼äº†ç¶ è‰²ç·šè·¯ (`exam -> assessment -> quiz`) çš„é€£æ¥é»ï¼
    // é€™äº›ç¯€é» (assessment, quiz) çš„ parentId ä¸ç­‰æ–¼ centerNodeId ('test')ï¼Œ
    // å› æ­¤å®ƒå€‘å¾æœªé€²å…¥ `categoryThreads` çš„è¨ˆç®—ä¸­ã€‚

    // é¡å¤–é‚è¼¯ï¼šè™•ç†éç›´æ¥å­ç¯€é»çš„çˆ¶å­é€£ç·š
    nodes.forEach(node => {
        if (node.parentId && node.parentId !== centerNodeId) {
            const parentNode = nodes.find(n => n.id === node.parentId);
            
            // ç¢ºä¿çˆ¶ç¯€é»å­˜åœ¨ä¸”å®ƒå€‘å±¬æ–¼åŒä¸€å€‹é¡åˆ¥ (é€™å°åŒç¾©è©éˆæ˜¯åˆç†çš„)
            if (parentNode && parentNode.category === node.category) {
                const categoryColor = getCategoryColor(node.category as WordCategory, isDark);

                // è¨ˆç®—çˆ¶ç¯€é»åˆ°å­ç¯€é»çš„é€£ç·šé‚Šç•Œ
                const startPoint = getNodeEdgeCoordinates(parentNode, node, NODE_WIDTH);
                const endPoint = getNodeEdgeCoordinates(node, parentNode, NODE_WIDTH);

                allLines.push({
                    key: `parent-${parentNode.id}-to-${node.id}`,
                    x1: startPoint.x,
                    y1: startPoint.y,
                    x2: endPoint.x,
                    y2: endPoint.y,
                    color: categoryColor,
                });
            }
        }
    });
    
Â  return (
Â  Â  <divÂ 
Â  Â  Â  // ... (å¤–å±¤ Div ä¿æŒä¸è®Š)
Â  Â  >
Â  Â  Â  {/* Canvas */}
Â  Â  Â  <div
Â  Â  Â  Â  // ... (å…§å±¤ Div ä¿æŒä¸è®Š)
Â  Â  Â  >
Â  Â  Â  Â  <svg
Â  Â  Â  Â  Â  className="absolute inset-0 pointer-events-none z-0" // ä¿æŒ z-0 åœ¨ç¯€é»ä¹‹ä¸‹
Â  Â  Â  Â  Â  style={{
Â  Â  Â  Â  Â  Â  transform: `translate(${pan.x}px, ${pan.y}px) scale(${zoom})`,
Â  Â  Â  Â  Â  Â  transformOrigin: "0 0",
Â  Â  Â  Â  Â  }}
Â  Â  Â  Â  >
Â  Â  Â  Â  Â  {allLines.map((line) => ( // ğŸ’¡ ä½¿ç”¨ allLines ç¹ªè£½æ‰€æœ‰ç·šæ®µ
Â  Â  Â  Â  Â  Â  <line
Â  Â  Â  Â  Â  Â  Â  key={line.key}
Â  Â  Â  Â  Â  Â  Â  x1={line.x1}
Â  Â  Â  Â  Â  Â  Â  y1={line.y1}
Â  Â  Â  Â  Â  Â  Â  x2={line.x2}
Â  Â  Â  Â  Â  Â  Â  y2={line.y2}
Â  Â  Â  Â  Â  Â  Â  stroke={line.color}
Â  Â  Â  Â  Â  Â  Â  strokeWidth={2}
Â  Â  Â  Â  Â  Â  Â  opacity={0.5}
Â  Â  Â  Â  Â  Â  />
Â  Â  Â  Â  Â  ))}
Â  Â  Â  Â  </svg>

Â  Â  Â  Â  {/* ç¯€é»å®¹å™¨ (z-10) ä¿æŒä¸è®Š */}
        // ... (AnimatePresence åŠç¯€é»æ¸²æŸ“é‚è¼¯ä¿æŒä¸è®Š)
Â  Â  Â  </div>
Â  Â  </div>
Â  );
}
é—œéµä¿®æ”¹ç¸½çµï¼š
æ–°å¢ getNodeEdgeCoordinatesï¼š å®ƒå˜—è©¦æ ¹æ“šå…©å€‹ç¯€é»çš„ä½ç½®ï¼Œè¨ˆç®—ç·šæ¢æ‡‰è©²å¾å“ªå€‹é‚Šç·£ï¼ˆå·¦ã€å³ã€ä¸Šã€ä¸‹ï¼‰é–‹å§‹å’ŒçµæŸï¼Œé€™æ¨£ç·šå°±ä¸æœƒç©¿éç¯€é»ä¸­å¿ƒã€‚

ç§»é™¤ä¸­å¿ƒé»æ’åºé‚è¼¯ï¼š åˆªé™¤äº†åŸç¨‹å¼ä¸­è¨ˆç®— furthestNode ä¸¦ç¹ªè£½å–®ä¸€ç›´ç·šçš„é‚è¼¯ã€‚

æ–°å¢ allLines æ”¶é›†å™¨ï¼š ç”¨ä¾†æ”¶é›†æ‰€æœ‰éœ€è¦ç¹ªè£½çš„ç¨ç«‹ç·šæ®µ (<line>)ã€‚

æ–°å¢ç·šæ€§é€£ç·šé‚è¼¯ï¼š

derivatives (æ°´å¹³æ’åˆ—) ä½¿ç”¨ sortedNodes çš„ for è¿´åœˆä¾†å¯¦ç¾ testing é€£ tester é€£ testable ç­‰ç­‰ã€‚

æ–°å¢éšå±¤é€£ç·šé‚è¼¯ï¼š

ç¶ è‰²çš„ synonyms ç·šè·¯ (exam -> assessment -> quiz) æ˜¯ä¸€ç¨®éšå±¤éˆã€‚å› ç‚º assessment å’Œ quiz çš„ parentId ä¸¦ä¸æ˜¯ centerNodeId (test)ï¼Œæ‰€ä»¥æˆ‘å€‘æ–°å¢äº†ä¸€å€‹ nodes.forEach è¿´åœˆä¾†å°ˆé–€æª¢æŸ¥æ‰€æœ‰éä¸­å¿ƒé»çš„çˆ¶å­é—œä¿‚ä¸¦ç¹ªè£½é€£ç·šã€‚

è«‹å°‡ getNodeEdgeCoordinates å‡½æ•¸å’Œ NODE_WIDTH å¸¸æ•¸æ”¾åœ¨ MindMapCanvas å‡½æ•¸å¤–éƒ¨ï¼Œç„¶å¾Œå°‡ä¿®æ”¹å¾Œçš„é€£ç·šé‚è¼¯æ›¿æ›åˆ°æ‚¨çš„ç¨‹å¼ç¢¼ä¸­ã€‚å¦‚æœé€£ç·šä»æœ‰åç§»ï¼Œè«‹å˜—è©¦èª¿æ•´ NODE_WIDTH çš„å€¼ã€‚